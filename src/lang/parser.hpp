//
// Created by Erik Hyrkas on 12/28/2022.
// Copyright 2022. Usable under MIT license.
//

// A parser takes in a list of tokens from a lexer and creates meaning from it.
// In this case, the goal is to create a dsl object that we can execute.
#ifndef HAPPYML_PARSER_HPP
#define HAPPYML_PARSER_HPP

#include "lexer.hpp"
#include "session_state.hpp"
#include "executable.hpp"
#include "happyml_ast_nodes.hpp"

using namespace std;

namespace happyml {



    class RuleMatch {
    public:
        explicit RuleMatch(const string &label, const vector<shared_ptr<Match>> &matches) {
            this->matches = matches;
        }
        explicit RuleMatch(const string &label, const vector<shared_ptr<RuleMatch>> &childMatches) {
            this->childMatches = childMatches;
        }
        string render(int indent=0) {
            stringstream result;
            for(int i = 0; i < indent; i++) {
                result << " ";
            }
            result << label << ":";
            if(!matches.empty()) {
                string delim;
                for(const auto& match : matches) {
                    result << delim << match->render();
                    delim = ", ";
                }
            } else {
                result << endl;
                for(const auto& match: childMatches) {
                    result << match->render(indent+1) << endl;
                }
            }
            return result.str();
        }
    private:
        string label;
        vector<shared_ptr<Match>> matches;
        vector<shared_ptr<RuleMatch>> childMatches;
    };

    class Rule {
    public :
        virtual shared_ptr<Executable> interpret(const shared_ptr<RuleMatch> &ruleMatch) = 0;
    };

    class RuleMatcher {
    public:
        explicit RuleMatcher(const shared_ptr<Rule> &rule) {
            this->rule = rule;
        }
        shared_ptr<Executable> match(const shared_ptr<MatchStream> &matchStream) {
            // TODO: return an executable object that has been generated by using the root rule
            // the root rule has children rules
            return nullptr;
        }
    private:
        shared_ptr<Rule> rule;
    };

    // A stateless parser, responsible for building an executable script.
    // The results could be cached, so we don't want to allow any session
    // state to influence what we build.
    class Parser {
    public:
        explicit Parser(const shared_ptr<Lexer> &lexer, const shared_ptr<RuleMatcher> &rootRuleMatcher) {
            this->lexer = lexer;
            this->rootRuleMatcher = rootRuleMatcher;
        }

        shared_ptr<Executable> parse(const string &text, const string &source = "unknown") {
            // lex to get tokens
            auto lexResult = lexer->lex(text, source);
            if (!lexResult->getMatchStream()) {
                return make_shared<ParseErrorStatement>(lexResult->getMessage());
            }

            cout << "Lexer: " << lexResult->getMessage() << endl << lexResult->getMatchStream()->render() << endl;
            // then build parsed result.
            return rootRuleMatcher->match(lexResult->getMatchStream());
        }

    private:
        shared_ptr<Lexer> lexer;
        shared_ptr<RuleMatcher> rootRuleMatcher;
    };

}
#endif //HAPPYML_PARSER_HPP
